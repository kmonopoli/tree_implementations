Report
Assignment: Project 6
Name: Kathryn Monopoli

I struggled most with the rebalanceLeft and rebalanceRight methods for the AVL tree. I needed to make some changes to the initial code in the rebalanceLeft method. While I understood that there was a problem with my implementation of the method, I required some help from the instructor to be sure how to move forward because some of the information in the textbook was incorrect with respect to the balance factors. I confirmed the changes to the code by creating a smaller version of the Books.txt input file and using the inorderPrint method to be sure the elements were added as expected. 

I spent ten hours on this project, however the first two hours (on 11/18) were spent solving an issue I had reading in the Books.txt file, and were not related to time spent to understand the material. After working out that problem, the rest of the project was fairly straightforward (excepting the issue I had implementing the AVL tree as described above). I completed most of the project on 11/19, working for about six hours. I spent an addition two hours on the project on 11/20 after meeting with the instructor to discuss the rebalanceLeft and rebalanceRight methods for the AVL tree. 

Overall the output from the three programs matched my expectations. The output for the BST matched my expectations. In the best case BST the height is logn, in the worst case the height is n, while on average the height is 1.386*logn (n being the number of internal nodes). Therefore for a tree with 147311 elements the best case height is approximately 17.17, the worst case height is 147311, and the average height is 23.80. The height of the BST in this project was 46, which meets expectations because it is between the best and worst case values, though it is a bit larger than the computed average height.

On average the number of comparisons for a successful search in a BST is 1.386*logn (n being the number of internal nodes). In this project the BST contained 147311 elements, and therefore the computed average number of comparisons for a successful search would be approximately 23.80 comparisons. This value is close to the output value, which was 23.23 comparisons. The best case average number of comparisons for a successful search for a BST is 1+logn. Therefore, the best case average number of comparisons for a successful search is computed to be approximately 18.17 comparisons. The worst case average number of comparisons for a successful search in a BST is (n+1)/2, therefore the worst case average number of comparisons was computed to be 73656 comparisons. 

The output for the AVL tree matched my expectations. The height of an AVL tree is between log(n+1) and 1.4404*log(n+2)-0.328 (n being the number of internal nodes). For a tree with 147311 elements the height would therefore be between approximately 17.17 and 24.40. The output for the height of the AVL tree was 20, which is between these values. 

The output for the Red-Black Tree matched my expectations. The height of a Red-Black Tree in the worst case is 2*log(n+1) (n being the number of internal nodes). Therefore, in this project with 147311 elements, the height of the Red-Black Tree is computed to be at most approximately 34.34. The output for the height of the Red-Black tree was 21, which is less than the maximum value.

From this project I learned how to implement three tree data structures. This project helped solidify my understanding of how the BST, AVL tree, and Red-Black Tree are related. This project also helped solidify my skills writing recursive methods.

A BST, AVL Tree, and Red-Black Tree are useful when one needs to perform search, add, and remove operations quickly on a dataset. For example, these trees could be useful in Air Traffic control, when one needs guaranteed performance, because there is an upper bound on the search time. All of the data must be stored in RAM, therefore these data structures do not work well with very large datasets.

